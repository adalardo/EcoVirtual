#         {
col_riq=rgb(col_func(seq(0,1, length.out=Nspp)), maxColorValue=255)
#         }
#          else{
#          col_riq=rgb(col_func(seq(0,1, length.out=nsppobs)), maxColorValue=255)
#          }
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=0.5, tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax=100, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
}
riq.tempo=t(apply(cena, c(2,3), sum))
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain, S=S)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("N Islands=",n.isl,"; N spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Number of species", ylab="Colonization\n (Number of species/cicle)", cex.axis=1.2, main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax=100, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
}
riq.tempo=t(apply(cena, c(2,3), sum))
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain, S=S)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1), mar=c(5,5,4,2))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("N Islands=",n.isl,"; N spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Number of species", ylab="Colonization\n (Number of species/cicle)", cex.axis=1.2, main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax=100, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
}
riq.tempo=t(apply(cena, c(2,3), sum))
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain, S=S)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1), mar=c(5,,4,2))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("N Islands=",n.isl,"; N spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", xlab="Number of species", ylab="Colonization\n (Number of species/cicle)", main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax=100, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
}
riq.tempo=t(apply(cena, c(2,3), sum))
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain, S=S)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1), mar=c(5,5,4,2))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("N Islands=",n.isl,"; N spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", xlab="Number of species", ylab="Colonization\n (Number of species/cicle)", main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE, tmax=100)
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
animaIsl=function(riq.tempo, ar.isl, locxy, sprain, col_riq=col_riq, S=S)
{
Nspp=S
nsppobs=max(riq.tempo)
maxt=dim(riq.tempo)[1]
nIsl<-length(ar.isl)
comp.max<-max(ar.isl)
tempo=length(riq.tempo)
col_spp=rainbow(max(riq.tempo))
col_func1=colorRamp(c("white", "green3"))
col_func2=colorRamp(c("green3", "green5"))
#          if(nsppobs/Nspp>0.1)
#         {
col_riq1=rgb(col_func1(seq(0,1, length.out=nsppobs)), maxColorValue=255)
col_riq2=rgb(col_func2(seq(0,1, length.out=Nspp-nsppobs)), maxColorValue=255)
col_riq=c(col_riq1,col_riq2)
#         }
#          else{
#          col_riq=rgb(col_func(seq(0,1, length.out=nsppobs)), maxColorValue=255)
#          }
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
animaIsl=function(riq.tempo, ar.isl, locxy, sprain, col_riq=col_riq, S=S)
{
Nspp=S
nsppobs=max(riq.tempo)
maxt=dim(riq.tempo)[1]
nIsl<-length(ar.isl)
comp.max<-max(ar.isl)
tempo=length(riq.tempo)
col_spp=rainbow(max(riq.tempo))
col_func1=colorRamp(c("white", "green3"))
col_func2=colorRamp(c("green3", "greenyellow"))
#          if(nsppobs/Nspp>0.1)
#         {
col_riq1=rgb(col_func1(seq(0,1, length.out=nsppobs)), maxColorValue=255)
col_riq2=rgb(col_func2(seq(0,1, length.out=Nspp-nsppobs)), maxColorValue=255)
col_riq=c(col_riq1,col_riq2)
#         }
#          else{
#          col_riq=rgb(col_func(seq(0,1, length.out=nsppobs)), maxColorValue=255)
#          }
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
animaIsl=function(riq.tempo, ar.isl, locxy, sprain, col_riq=col_riq, S=S)
{
Nspp=S
nsppobs=max(riq.tempo)
maxt=dim(riq.tempo)[1]
nIsl<-length(ar.isl)
comp.max<-max(ar.isl)
tempo=length(riq.tempo)
col_spp=rainbow(max(riq.tempo))
col_func1=colorRamp(c("white", "greenyellow"))
col_func2=colorRamp(c("greenyellow","green4"))
#          if(nsppobs/Nspp>0.1)
#         {
col_riq1=rgb(col_func1(seq(0,1, length.out=nsppobs)), maxColorValue=255)
col_riq2=rgb(col_func2(seq(0,1, length.out=Nspp-nsppobs)), maxColorValue=255)
col_riq=c(col_riq1,col_riq2)
#         }
#          else{
#          col_riq=rgb(col_func(seq(0,1, length.out=nsppobs)), maxColorValue=255)
#          }
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
animaIsl=function(riq.tempo, ar.isl, locxy, sprain, col_riq=col_riq, S=S)
{
Nspp=S
nsppobs=max(riq.tempo)
maxt=dim(riq.tempo)[1]
nIsl<-length(ar.isl)
comp.max<-max(ar.isl)
tempo=length(riq.tempo)
col_spp=rainbow(max(riq.tempo))
col_func1=colorRamp(c("white", "green4"))
col_func2=colorRamp(c("green4", "royalblue"))
#          if(nsppobs/Nspp>0.1)
#         {
col_riq1=rgb(col_func1(seq(0,1, length.out=nsppobs)), maxColorValue=255)
col_riq2=rgb(col_func2(seq(0,1, length.out=Nspp-nsppobs)), maxColorValue=255)
col_riq=c(col_riq1,col_riq2)
#         }
#          else{
#          col_riq=rgb(col_func(seq(0,1, length.out=nsppobs)), maxColorValue=255)
#          }
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0.3, tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, S=100, seed.rain=100, abund=0, tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax=100, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
}
riq.tempo=t(apply(cena, c(2,3), sum))
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain, S=S)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1), mar=c(5,5,4,2))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("N Islands=",n.isl,"; N spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", xlab="Number of species", ylab="Colonization\n (Number of species/cicle)", main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=rep(10,1000), tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=0.5, tmax=100, anima=TRUE)
help(plot.lm)
example(plot.lm)
zx11()
x11()
example(plot.lm)
plot.lm
