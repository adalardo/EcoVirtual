jovem=which(j.vf)
pais[,,tc][jovem]<-sample(c(0,2,3),length(jovem),replace=TRUE, prob=c((1-(p.jj+p.ja)),p.jj,p.ja))
}
a.vf=pais[,,(tc-1)]==3
if(sum(a.vf)>0)
{
adulto=which(a.vf)
pais[,,tc][adulto]<-sample(c(0,3),length(adulto),replace=TRUE, prob=c((1-p.aa),p.aa))
}
n.fec=round(fec*sum(a.vf))
vazio=which(pais[,,tc]==0)
#match(vazio,ind.sem)
sv=vazio%in% ind.sem
if(sum(sv)>0)
{
sem.vazio=vazio[sv]
pais[,,tc][sem.vazio]<-sample(c(0,2),sum(sv),replace=TRUE, prob=c((1-p.sj),p.sj))
}
if(sum(pais[,,tc])==0 & n.fec==0)
{
image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="", add=TRUE)
grid(rw,cl)
text(rw/2, cl/2, "EXTINCTION", col="red", cex=4)
break
}
#	if(sum[pais[,,tc]==0 & n.fec>0)
#	{
#	image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="", add=TRUE)
#	#text(rw/2, cl/2, "EXTINTION", col="red", cex=4)
#	grid(rw,cl)
#	stop()
#	}
image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="", add=TRUE)
image(0:rw, 0:cl, pais[,,tc], col=c("white", "green", "darkgreen") ,breaks=c(0,1,2,3), xlab="", ylab="",  add=TRUE, sub=paste("simulation no. =",tc ))
grid(rw,cl)
xsem=sample(seq(0,cl,0.1), n.fec, replace=TRUE)
ysem=sample(seq(0,rw,0.1), n.fec, replace=TRUE)
xy.sem[[2]]=cbind(x=xsem,y=ysem)
ind.sem=floor(ysem)*cl + ceiling(xsem)
points(xsem,ysem, col="red", pch=16)
Sys.sleep(.1)
t.fr=table(pais[,,tc])
tab.fr[tc,as.numeric(names(t.fr))+1]<-t.fr[]
tab.fr[tc,2]<-n.fec
}
tab.rel=tab.fr/apply(tab.fr,1,sum)
names(tab.rel)<-c("Empty", "Seed", "Juvenil", "Adult")
x11()
matplot(tab.rel, type="l",col=c("gray", "red", "green", "darkgreen"),lwd=2,main= "Stage Frequency", ylab="Frequency", xlab="Time (t)")
legend("topright",legend=c("Empty", "Seed", "Juvenil", "Adult") ,lty=1:4, col=c("gray", "red", "green", "darkgreen"), bty="n", cex=0.8 )
#t.sim=apply(pais,3, table)
invisible(list(simula=pais, xy=xy.sem))
}
#popStr(p.sj=0.05, p.jj=0.99, p.ja=0, p.aa=1, fec=1.2, ns=100,nj=150,na=50, rw=20, cl=20, tmax=100)
#popStr(0.1,0.4,0.3,0.9,1.2,100,80,20, 20,20,100)
estExp(N0=1000,r=0.0488,varr=0.005,tmax=100)
estDem(N0=100, b=0.55, d=0.5, tmax=50)
crescLog(N0=10, r=0.05, K=80, tmax=100)
popStr(p.sj=0.05, p.jj=0.99, p.ja=0, p.aa=1, fec=1.2, ns=100,nj=150,na=50, rw=20, cl=20, tmax=100)
comCompete = function(tmax,rw,cl, S, fi, fsp1, pe,fr=0,int=0)
{
rank=1:S
vetor_dist=rep("n", tmax)
if(fr>0 & int>0)
{
#  n_dist=round(tmax*fr,0)
#  max_dist=n_dist*fr
vetor_dist[round(seq(0,tmax, length.out=fr*tmax),0)[-1]]="d"
}
vetor_dist=vetor_dist[-1]
ci= pe/(1-fsp1)^(2*rank-1)
N <- rw*cl
resulta=matrix(nrow=S,ncol=tmax)
attributes(resulta)=c(attributes(resulta),list(tempo=tmax, riqueza=S, n_manchas=N, inicial= fi, comp=fsp1, coloniza=ci, freq_dist=fr, int=int))
n_ocup= sum(fi)*N
temp=1
if(length(fi)==S)
{
resulta[,1]=fi
antes=sample(c(rep(0,N-n_ocup),rep(rank,each=fi*N)))
}
if(length(fi)==1)
{
antes <- sample(c(1:S, sample(1:S, (n_ocup-S),replace=TRUE), rep(0, N-n_ocup)))
t_antes=table(antes)
n_sp=rep(0,S)
names_antes=match(as.numeric(names(t_antes)), rank)
rank_antes=match(rank,as.numeric(names(t_antes)))
n_sp[na.omit(names_antes)]=t_antes[na.omit(rank_antes)]
resulta[,1]<-n_sp/N
}
for (f in vetor_dist)
{
temp=temp+1
depois <- rep(0,N)
#ncum=cumsum(resulta[,1])-resulta[1,1] ## o que Ã© isso?
pi=ci*resulta[,temp-1]
pi[pi>1]=0.999
for(rs in S:1)
{
depois[antes==rs]<-sample(c(0,rs),sum(antes==rs),replace=TRUE,prob=c(pe,1-pe))
d1<-sample(c(0,rs),sum(antes>rs | antes==0),replace=TRUE,prob=c(1-pi[rs],pi[rs]))
depois[antes>rs | antes==0][d1==rs] <- rs
}
n_sp=rep(0,S)
if(f=="d")
{
depois[sample(1:N,N*int)]=0
}
t_depois=table(depois)
names_match=match(as.numeric(names(t_depois)), rank)
rank_match=match(rank,as.numeric(names(t_depois)))
n_sp[na.omit(names_match)]=t_depois[na.omit(rank_match)]
resulta[,temp]<-n_sp/N
antes<-depois
}
#grafico
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(4,1))
matplot(1:tmax,t(resulta),type="l", lty=3, col=rainbow(S),bty="n", lwd=2,xlab="Time", ylab="Patch occupancy", main="Competition/Colonization Trade-off", sub=paste("\n best competitor abundance=",fsp1,"; mortality rate=",pe, "; disturbance frequency=",fr, "; disturbance intensity=", int), cex.sub=0.7)
old<-par(mar=c(3,5,2,4))
image(x=1:S, y=1, matrix(data=1:S, nrow=S,ncol=1),col=rainbow(S), xlab="competition/colonizatio scale", ylab="",xaxt="n", yaxt="n")
axis(1, at=c(1.5,9.5),tick=FALSE, labels=c("better competitor", "better colonizator"))
par(old)
##resultado
invisible(resulta)
}
comCompete(tmax=1000,rw=100,cl=100, S=10, fi=1, fsp1=0.20, pe=0.01,fr=0,int=0)
regNicho=function(tmax, rw, cl, c1,c2, ec, dst,  er, sc, mx, rs)
{
N=cl*rw
V=1-er-sc-mx-rs
cena=array(NA,dim=c(rw,cl,tmax))
cena[,,1]<-sample(c(0:4), N, prob=c(V,er,sc,mx, rs), replace=TRUE)
resulta=matrix(0, ncol=5, nrow = tmax)
conta=table(cena[,,1])/N
resulta[1,(as.numeric(names(conta))+1)]<-conta
for (t in 2:tmax)
{
Vvf<-cena[,,t-1]==0
nV=sum(Vvf)
ervf<-cena[,,t-1]==1
ner=sum(ervf)
scvf<-cena[,,t-1]==2
nsc=sum(scvf)
mxvf<-cena[,,t-1]==3
nmx=sum(mxvf)
rsvf<-cena[,,t-1]==4
nrs=sum(rsvf)
p_col1=c1*(nsc+nmx+nrs)/N
p_col2=c2*(ner+nmx)/N
p_ncol=1-p_col1- p_col2
p_permer = 1- (dst + p_col1)
p_permsc = 1- (dst + p_col2 + ec)
p_permmx = 1 - (dst + ec)
if(p_ncol<0){p_ncol=0}
if(p_permer<0){p_permer=0}
if(p_permsc<0){p_permsc=0}
if(p_permmx<0){p_permmx=0}
cena[,,t][Vvf]<-sample(c(0,1,2),nV, replace=TRUE, prob=c(p_ncol,p_col2,p_col1))
cena[,,t][ervf]<-sample(c(0,1,3), ner, replace=TRUE, prob=c(dst,p_permer , p_col1))
cena[,,t][scvf]<-sample(c(0,2,3,4), nsc, replace=TRUE, prob=c(dst,p_permsc, p_col2, ec))
cena[,,t][mxvf]<-sample(c(0,3,4), nmx, replace=TRUE, prob=c(dst,p_permmx, ec))
cena[,,t][rsvf]<-sample(c(0,4), nrs, replace=TRUE, prob=c(dst,1 - dst))
conta=table(cena[,,t])/N
resulta[t,(as.numeric(names(conta))+1)]<-conta
}
animaCena(cena)
x11()
matplot( 1:tmax,resulta[,2:5], type="l", main="Niche Regeneration Model" , xlab="time", ylab="State proportion", lty=2:5, col=2:5)
legend("topright", c("Early", "Susceptible", "Mixed", "Resistant"), bty="n", lty=2:5, col=2:5, cex=0.7)
invisible(cena)
}
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
animaCena=function(dados)
{
nt=dim(dados)[3]
x11()
op=par(mfrow=c(5,5),  mar=c(0.1,0.1,0.1,0.1))
for(i in 1:nt)
{
image(dados[,,i], main="",  bty="n",xaxt='n',yaxt='n', col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
}
x11()
par(mfrow=c(2,2))
image(dados[,,1], main= paste("Patches occupancy\n \ttime=", 1 ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,round(nt/3)], main= paste("Patches occupancy\n \t time=", round(nt/3) ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,round(2*nt/3)], main= paste("Patches occupancy\n \ttime=", round(2*nt/3) ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,nt], main= paste("Patches occupancy\n \t time=", nt ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
par(op)
}
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | lenmatgth(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
matrix(0.5,0.5,0.5,0.5)
x
dev{{{}}}
]
)
))
=
+
dev.off()
esc
mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2)
rstudio::viewData(mat.trans)
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | lenmatgth(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
#sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c90.5,0.5),rw=20,cl=20, tmax=100 )
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c90.5,0.5),rw=20,cl=20, tmax=100 )
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100 )
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | length(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100)
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | length(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
x11()
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100)
compLV=function(n01,n02,tmax,r1,r2,k1,k2,alfa,beta)
{
resulta=matrix(0, ncol=3, nrow=tmax)
resulta[,1]=0:(tmax-1)
resulta[1,c(2,3)]=c(n01,n02)
for(t in 2:tmax)
{
nsp1=resulta[(t-1),2]
nsp2=resulta[(t-1),3]
resulta[t,2]=nsp1 + r1*nsp1*((k1-nsp1-alfa*nsp2)/k1)
resulta[t,3]=nsp2 + r2*nsp2*((k2-nsp2-beta*nsp1)/k2)
if (resulta[t,2]<1)
{
resulta[t,2]=0
}
if (resulta[t,3]<1)
{
resulta[t,3]=0
}
}
x11()
old=par(mfrow=c(1,2), mar=c(4,4,2,1))
plot(resulta[,1],resulta[,2],ylim=c(0,max(na.omit(resulta[,2:3]))),type="l",lty=4,xlab="time (t)",ylab="Population size", main="Population Growth", col="blue", lwd=1.5 )
legend("topleft", legend=c("Sp. 1", "Sp. 2"), lty=4, col=c("blue", "green"), bty="n", cex=0.8)
lines(resulta[,1],resulta[,3], col="green", lty=4, lwd=1.5)
plot(resulta[,2],resulta[,3],type="l",col="red",xlab="N1",ylab="N2",ylim=c(0,max(c(na.omit(resulta[,3]),k1/alfa,k2))),xlim=c(0,max(c(na.omit(resulta[,2]),k2/beta,k1))), main="Isoclines")
segments(0,k1/alfa,k1,0,lty=4, lwd=1.5, col="blue")
segments(0,k2,k2/beta,0,lty=4,lwd=1.5, col="green" )
legend("topleft", title="Equilibrium without habitat destruction",legend=c("isocline sp.1 ", "Isocline sp. 2", "Populations trajectory"), lty=c(4,4,1), col=c("blue", "green", "red"), bty="n", cex=0.8)
invisible(resulta)
}
compLV(n01=10, n02=10,r1=0.05, r2=0.03, k1=80, k2=50, alfa=1.2, beta=0.5, tmax=200)
load('bichos.rdata')
load('bichos.Rdata')
read('bichos.Rdata')
open('bichos.Rdata')
load('/bichos.Rdata')
setwd()
getwd
setwd()
