porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | length(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
x11()
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
sucMatrix(mat.trans=matrix(data=c(0.5,0.5,0.5,0.5), nrow=2), init.prop=c(0.5,0.5),rw=20,cl=20, tmax=100)
compLV=function(n01,n02,tmax,r1,r2,k1,k2,alfa,beta)
{
resulta=matrix(0, ncol=3, nrow=tmax)
resulta[,1]=0:(tmax-1)
resulta[1,c(2,3)]=c(n01,n02)
for(t in 2:tmax)
{
nsp1=resulta[(t-1),2]
nsp2=resulta[(t-1),3]
resulta[t,2]=nsp1 + r1*nsp1*((k1-nsp1-alfa*nsp2)/k1)
resulta[t,3]=nsp2 + r2*nsp2*((k2-nsp2-beta*nsp1)/k2)
if (resulta[t,2]<1)
{
resulta[t,2]=0
}
if (resulta[t,3]<1)
{
resulta[t,3]=0
}
}
x11()
old=par(mfrow=c(1,2), mar=c(4,4,2,1))
plot(resulta[,1],resulta[,2],ylim=c(0,max(na.omit(resulta[,2:3]))),type="l",lty=4,xlab="time (t)",ylab="Population size", main="Population Growth", col="blue", lwd=1.5 )
legend("topleft", legend=c("Sp. 1", "Sp. 2"), lty=4, col=c("blue", "green"), bty="n", cex=0.8)
lines(resulta[,1],resulta[,3], col="green", lty=4, lwd=1.5)
plot(resulta[,2],resulta[,3],type="l",col="red",xlab="N1",ylab="N2",ylim=c(0,max(c(na.omit(resulta[,3]),k1/alfa,k2))),xlim=c(0,max(c(na.omit(resulta[,2]),k2/beta,k1))), main="Isoclines")
segments(0,k1/alfa,k1,0,lty=4, lwd=1.5, col="blue")
segments(0,k2,k2/beta,0,lty=4,lwd=1.5, col="green" )
legend("topleft", title="Equilibrium without habitat destruction",legend=c("isocline sp.1 ", "Isocline sp. 2", "Populations trajectory"), lty=c(4,4,1), col=c("blue", "green", "red"), bty="n", cex=0.8)
invisible(resulta)
}
compLV(n01=10, n02=10,r1=0.05, r2=0.03, k1=80, k2=50, alfa=1.2, beta=0.5, tmax=200)
load('bichos.rdata')
load('bichos.Rdata')
read('bichos.Rdata')
open('bichos.Rdata')
load('/bichos.Rdata')
setwd()
getwd
setwd()
teste.t <- 2-2*(pt(2.2, 19))
limite <- qt(0.975, 19)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
#lado.isl=sqrt(ar.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n abundance vector length is different from the number of species, only the first value considered\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n maximum eveness\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n geometric species rank-abundance distribution\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
#		nsemIlh=function(x,y,...){comp.isl<=x & comp.ils}
#		outer(loc.x, loc.y, sum  )
#v.x=loc.x<ar.isl[l]
#v.y=loc.y<ar.isl[l]
#v.spp=unique(chuva[v.x & v.y])
#cena[v.spp,l,1]<-1
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
#		if(i>1 & anima==TRUE)
#		animaIsl(cena[,,i],ar.isl, S, loc.x, loc.y, chuva,i)
}
riq.tempo=t(apply(cena, c(2,3), sum))
x11()
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("Nº Islands=",n.isl,"; Nº spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Species Number", ylab="Colonization (species/cicle)", cex.axis=1.2, main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=rep(10,1000), tmax=100, anima=TRUE) #abund 'NORMAL'
animaIsl=function(riq.tempo, ar.isl, locxy, sprain, col_riq=col_riq)
{
Nspp=max(riq.tempo)
maxt=dim(riq.tempo)[1]
nIsl<-length(ar.isl)
comp.max<-max(ar.isl)
tempo=length(riq.tempo)
col_spp=rainbow(max(riq.tempo))
col_func=colorRamp(c("white", "green3"))
col_riq=rgb(col_func(seq(0,1, length.out=Nspp)), max=255)
## aqui inicia o grafico
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,3))
image(x=1:Nspp, y=1, matrix(data=1:Nspp, nrow=Nspp,ncol=1),col=col_riq, ylab="",xlab=paste("cicle", 1:length(maxt)), xaxt="n", yaxt="n", main="Richness")
axis(3, at=c(1.5,Nspp),tick=FALSE, labels=c("0", Nspp), mgp=c(0,0,0))
polygon(x=c(1.5,1.5,Nspp,Nspp), y=c(0.6,1.4,1.4,0.6), lwd=2)
plot(0:comp.max, 0:comp.max, usr=c(0,comp.max,0,comp.max), type="n", yaxt="n", xaxt="n", xlab="", ylab="", bty="n", main="Passive Sampling and Area ",mar=c(0,2,3,2), oma=c(0,0,0,0))
segments(x0=c(0,0,comp.max,0), y0=c(0,0,0,comp.max), x1=c(0,rep(comp.max,3)), y1=c(comp.max,0,comp.max,comp.max))
segments(x0=c(rep(0,nIsl), ar.isl), y0=c(ar.isl,rep(0,nIsl)), x1=c(ar.isl,ar.isl), y1=c(ar.isl,ar.isl))
for (i in 2:maxt)
{
lxy=locxy[[i]]
nspp=riq.tempo[i,]
for(f in nIsl:1)
{
vert=ar.isl[f]
polygon(x=c(0,vert, vert,0),y=c(0,0,vert,vert), col=col_riq[nspp[f]] )
}
points(lxy[,1],lxy[,2], col=col_spp[sprain[[i]]], pch=16)
Sys.sleep(.1)
}
par(old)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=rep(10,1000), tmax=100, anima=TRUE) #abund 'NORMAL'
bioGeoIsl=function(areas , dist , P , weight.A=.5 , a.e=1, b.e=-.01, c.i=1, d.i=-.01,e.i=0, f.i=.01,g.e=0, h.e=.01)
{
x11()
nf <- layout(matrix(c(1,2), 2, 1),widths=c(1), heights=c(4,1))
#layout.show(nf)
def_par<-par(mar=c(4,7,3,7))
E=((a.e+b.e*areas)*weight.A+(g.e+h.e*dist)*(1-weight.A))
I=((c.i+d.i*dist)*weight.A+(e.i+f.i*areas)*(1-weight.A))
#E=((b*areas)*weight.A + (h*dist)*(1-weight.A))
#I=((d*dist)*weight.A+(f*areas)*(1-weight.A))
I[I<=0]<-0.001
E[E<=0]<-0.001
#E=((b*r.areas) * weight.A) + ((h*r.dist)*(1-weight.A))
#I= ((d*r.dist) * (1-weight.A)) + (f*r.areas*weight.A)
S=I*P/(I+E)
T=I*E/(I+E)
nIsl=length(areas)
grColExt(E=E , I=I , P=P, areas=areas)
ex=data.frame(areas=areas,spp=S,dist=dist)
par(mar=c(0,0,0,0))
plot(1:10, 1:10, type="n", xlab="", ylab="", bty="n", xaxt="n", yaxt="n")
points(rep(4,nIsl), 2:(nIsl+1), col=rainbow(nIsl))
text(c (5, 6),c(nIsl+3,nIsl+3), c("Size","Distance"))
text(rep(5,nIsl),2:(nIsl+1), areas)
text(rep(6,nIsl),2:(nIsl+1), dist)
segments(4.5,nIsl+2, 6.5, nIsl+2)
segments(4.5, nIsl+3, 4.5, 1)
par(def_par)
invisible(ex)
}
grColExt=function(E , I , P, areas)
{
S = I*P/(I+E) ; T = I*E/(I+E)
nIsl=length(E)
corIsl=rainbow(nIsl)
curve(I[1]-I[1]*x/P[1],0,P[1],bty="n",xlab="Number of Species", ylab="Rate",xaxt="n",yaxt="n", font.lab=2,lwd=2,ylim=c(0,1),  main="Island Biogeography", col=corIsl[1])
curve((E[1]/P[1])*x,0,P,lwd=2,add=TRUE, col=corIsl[1], lty=2) #xlim=c(0,1),
legend("top", legend=c("Colonization", "Extinction"),  bty="n",lty=c(1,2))
abline(v=0)
abline(h=0)
mtext("St",side=1,at=P,font=2, line=1)
linhas=seq(0,1.5, length.out=nIsl)
for(i in 1:nIsl)
{
curve(I[i]-I[i]*x/P,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=1)
curve((E[i]/P)*x,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=2)
mtext(paste("S", i, sep=""),side=1,at=S[i], cex=0.8,font=2,col=corIsl[i], line=linhas[i])
mtext(paste("T", i, sep=""),side=2,at=T[i],cex=0.8,font=2,las=1,col=corIsl[i], line=linhas[i])
points(S[i],T[i],col=corIsl[i],pch=16,cex=1)
if(length(unique(areas))>1)
{
siz_ar=2 +(areas/max(areas))
points(S[i],T[i],col=corIsl[i],cex=siz_ar[i])
}
segments(S[i],T[i],S[i],0,lty=3,col=corIsl[i])
segments(S[i],T[i],0,T[i],lty=3,col=corIsl[i])
Sys.sleep(0.1)
}
#	mtext("I",side=2,at=I,font=2,las=1, line=2)
#	mtext("E",side=4,at=E,font=2,las=1)
}
bioGeoIsl(areas=c(5,10,50,80) , dist=c(10,100,100,10), P=100 , weight.A=.5 , a=1, b=-.01, c=1, d=-.01, e=0, f=.01, g=0, h=.01)
fix(arquip)
comCompete = function(tmax,rw,cl, S, fi, fsp1, pe,fr=0,int=0)
{
rank=1:S
vetor_dist=rep("n", tmax)
if(fr>0 & int>0)
{
#  n_dist=round(tmax*fr,0)
#  max_dist=n_dist*fr
vetor_dist[round(seq(0,tmax, length.out=fr*tmax),0)[-1]]="d"
}
vetor_dist=vetor_dist[-1]
ci= pe/(1-fsp1)^(2*rank-1)
N <- rw*cl
resulta=matrix(nrow=S,ncol=tmax)
attributes(resulta)=c(attributes(resulta),list(tempo=tmax, riqueza=S, n_manchas=N, inicial= fi, comp=fsp1, coloniza=ci, freq_dist=fr, int=int))
n_ocup= sum(fi)*N
temp=1
if(length(fi)==S)
{
resulta[,1]=fi
antes=sample(c(rep(0,N-n_ocup),rep(rank,each=fi*N)))
}
if(length(fi)==1)
{
antes <- sample(c(1:S, sample(1:S, (n_ocup-S),replace=TRUE), rep(0, N-n_ocup)))
t_antes=table(antes)
n_sp=rep(0,S)
names_antes=match(as.numeric(names(t_antes)), rank)
rank_antes=match(rank,as.numeric(names(t_antes)))
n_sp[na.omit(names_antes)]=t_antes[na.omit(rank_antes)]
resulta[,1]<-n_sp/N
}
for (f in vetor_dist)
{
temp=temp+1
depois <- rep(0,N)
#ncum=cumsum(resulta[,1])-resulta[1,1] ## o que é isso?
pi=ci*resulta[,temp-1]
pi[pi>1]=0.999
for(rs in S:1)
{
depois[antes==rs]<-sample(c(0,rs),sum(antes==rs),replace=TRUE,prob=c(pe,1-pe))
d1<-sample(c(0,rs),sum(antes>rs | antes==0),replace=TRUE,prob=c(1-pi[rs],pi[rs]))
depois[antes>rs | antes==0][d1==rs] <- rs
}
n_sp=rep(0,S)
if(f=="d")
{
depois[sample(1:N,N*int)]=0
}
t_depois=table(depois)
names_match=match(as.numeric(names(t_depois)), rank)
rank_match=match(rank,as.numeric(names(t_depois)))
n_sp[na.omit(names_match)]=t_depois[na.omit(rank_match)]
resulta[,temp]<-n_sp/N
antes<-depois
}
#grafico
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(4,1))
matplot(1:tmax,t(resulta),type="l", lty=3, col=rainbow(S),bty="n", lwd=2,xlab="Time", ylab="Patch occupancy", main="Competition/Colonization Trade-off", sub=paste("\n best competitor abundance=",fsp1,"; mortality rate=",pe, "; disturbance frequency=",fr, "; disturbance intensity=", int), cex.sub=0.7)
old<-par(mar=c(3,5,2,4))
image(x=1:S, y=1, matrix(data=1:S, nrow=S,ncol=1),col=rainbow(S), xlab="competition/colonizatio scale", ylab="",xaxt="n", yaxt="n")
axis(1, at=c(1.5,9.5),tick=FALSE, labels=c("best competitor", "best colonizator"))
par(old)
##resultado
invisible(resulta)
}
#comCompete(tmax=1000,rw=100,cl=100, S=10, fi=1, fsp1=0.20, pe=0.01,fr=0,int=0)
## Sucessional stages matrix
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | length(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
x11()
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Initial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
comCompete(tmax=1000,rw=100,cl=100, S=10, fi=1, fsp1=0.20, pe=0.01,fr=0,int=0)
regNicho=function(tmax, rw, cl, c1,c2, ec, dst,  er, sc, mx, rs)
{
N=cl*rw
V=1-er-sc-mx-rs
cena=array(NA,dim=c(rw,cl,tmax))
cena[,,1]<-sample(c(0:4), N, prob=c(V,er,sc,mx, rs), replace=TRUE)
resulta=matrix(0, ncol=5, nrow = tmax)
conta=table(cena[,,1])/N
resulta[1,(as.numeric(names(conta))+1)]<-conta
for (t in 2:tmax)
{
Vvf<-cena[,,t-1]==0
nV=sum(Vvf)
ervf<-cena[,,t-1]==1
ner=sum(ervf)
scvf<-cena[,,t-1]==2
nsc=sum(scvf)
mxvf<-cena[,,t-1]==3
nmx=sum(mxvf)
rsvf<-cena[,,t-1]==4
nrs=sum(rsvf)
p_col1=c1*(nsc+nmx+nrs)/N
p_col2=c2*(ner+nmx)/N
p_ncol=1-p_col1- p_col2
p_permer = 1- (dst + p_col1)
p_permsc = 1- (dst + p_col2 + ec)
p_permmx = 1 - (dst + ec)
if(p_ncol<0){p_ncol=0}
if(p_permer<0){p_permer=0}
if(p_permsc<0){p_permsc=0}
if(p_permmx<0){p_permmx=0}
cena[,,t][Vvf]<-sample(c(0,1,2),nV, replace=TRUE, prob=c(p_ncol,p_col2,p_col1))
cena[,,t][ervf]<-sample(c(0,1,3), ner, replace=TRUE, prob=c(dst,p_permer , p_col1))
cena[,,t][scvf]<-sample(c(0,2,3,4), nsc, replace=TRUE, prob=c(dst,p_permsc, p_col2, ec))
cena[,,t][mxvf]<-sample(c(0,3,4), nmx, replace=TRUE, prob=c(dst,p_permmx, ec))
cena[,,t][rsvf]<-sample(c(0,4), nrs, replace=TRUE, prob=c(dst,1 - dst))
conta=table(cena[,,t])/N
resulta[t,(as.numeric(names(conta))+1)]<-conta
}
animaCena(cena)
x11()
matplot( 1:tmax,resulta[,2:5], type="l", main="Niche Regeneration Model" , xlab="time", ylab="Patch occupancy", lty=2:5, col=2:5)
legend("topright", c("Early", "Susceptible", "Mixed", "Resistant"), bty="n", lty=2:5, col=2:5, cex=0.7)
invisible(cena)
}
#regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
animaCena=function(dados)
{
nt=dim(dados)[3]
x11()
op=par(mfrow=c(5,5),  mar=c(0.1,0.1,0.1,0.1))
for(i in 1:nt)
{
image(dados[,,i], main="",  bty="n",xaxt='n',yaxt='n', col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
}
x11()
par(mfrow=c(2,2))
image(dados[,,1], main= paste("Patch occupancy\n \t time=", 1 ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,round(nt/3)], main= paste("Patch occupancy\n \t time=", round(nt/3) ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,round(2*nt/3)], main= paste("Patch occupancy\n \ttime=", round(2*nt/3) ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
image(dados[,,nt], main= paste("Patch occupancy\n \t time=", nt ),  bty="n",xaxt='n',yaxt='n',col=c("white", "yellow", "orange", "blue", "green"))
grid(dim(dados)[2],dim(dados)[1])
par(op)
}
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
comCompete(tmax=1000,rw=100,cl=100, S=10, fi=1, fsp1=0.20, pe=0.01,fr=0,int=0)
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
compLV=function(n01,n02,tmax,r1,r2,k1,k2,alfa,beta)
{
resulta=matrix(0, ncol=3, nrow=tmax)
resulta[,1]=0:(tmax-1)
resulta[1,c(2,3)]=c(n01,n02)
for(t in 2:tmax)
{
nsp1=resulta[(t-1),2]
nsp2=resulta[(t-1),3]
resulta[t,2]=nsp1 + r1*nsp1*((k1-nsp1-alfa*nsp2)/k1)
resulta[t,3]=nsp2 + r2*nsp2*((k2-nsp2-beta*nsp1)/k2)
if (resulta[t,2]<1)
{
resulta[t,2]=0
}
if (resulta[t,3]<1)
{
resulta[t,3]=0
}
}
x11()
old=par(mfrow=c(1,2), mar=c(4,4,2,1))
plot(resulta[,1],resulta[,2],ylim=c(0,max(na.omit(resulta[,2:3]))),type="l",lty=4,xlab="time (t)",ylab="Population size", main="Population Growth", col="blue", lwd=1.5 )
legend("topleft", legend=c("Sp. 1", "Sp. 2"), lty=4, col=c("blue", "green"), bty="n", cex=0.8)
lines(resulta[,1],resulta[,3], col="green", lty=4, lwd=1.5)
plot(resulta[,2],resulta[,3],type="l",col="red",xlab="N1",ylab="N2",ylim=c(0,max(c(na.omit(resulta[,3]),k1/alfa,k2))),xlim=c(0,max(c(na.omit(resulta[,2]),k2/beta,k1))), main="Isoclines")
segments(0,k1/alfa,k1,0,lty=4, lwd=1.5, col="blue")
segments(0,k2,k2/beta,0,lty=4,lwd=1.5, col="green" )
legend("topleft", title="Equilibrium without habitat destruction",legend=c("isocline sp.1 ", "Isocline sp. 2", "Populations trajectory"), lty=c(4,4,1), col=c("blue", "green", "red"), bty="n", cex=0.8)
#invisible(resulta)
return(resulta)
}
compLV(n01=10, n02=10,r1=0.05, r2=0.03, k1=80, k2=50, alfa=1.2, beta=0.5, tmax=200)
