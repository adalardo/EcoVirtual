sleep=0.01
if(cont>5e4){sleep=0}
if(all.eq){
x1=rep(x1max,S)
}else{
x1 <- sample(1:x1max,S,replace=TRUE)
}
results <- matrix(NA,nrow=1+tmax/cont,ncol=S)
results[1,] <- x1
X <- x1
for(i in 2:(1+tmax/cont)){
for(j in 1:cont){
X[X<=0] <- NA
X <- X +sample(c(step,-1*step),S,replace=TRUE)
}
results[i,] <- X
}
results[is.na(results)] <- 0
time <- seq(0,tmax,by=cont)
x11()
animaRandWalk(rwData=results, time= time, sleep=sleep)
invisible(results)
#  matplot(time,results,type="l", col=rainbow(S),lwd=2, xlab="Steps",  main="Randon Walk",ylab="Distance from the edge")
#  abline(h=0,lwd=4)
}
animaRandWalk = function(rwData, time=2, sleep=0.1)
{
#par( )
xplus=max(time)*0.1
ymax=max(apply(rwData, 2, max))[1]
plot(time, rwData[,which.max(apply(rwData, 2, max))[1]], xlab="Steps", ylab="Distance from the edge",cex.axis=1.2, cex.lab=1.2,ylim=c(-.1* ymax,ymax), main="Randon Walk", cex.main=1.5, type="n", xlim=c(0,max(time)))
polygon(x=c(-xplus, -xplus, max(time)+xplus, max(time)+xplus), y=c(ymax*-0.15,0,0,ymax*-0.15), col="gray")
text(max(time)/2, -0.05* ymax, labels="Absortion Surface", col="red", cex=1.5)
n=dim(rwData)[2]
#ncolors= terrain.colors(n)
ncolors= rainbow(n)
for(i in 2:length(time))
{
for(j in 1:n)
{
lines(time[1:i], rwData[1:i,j], col=ncolors[j], lty=j )
}
Sys.sleep(sleep)
}
}
randWalk(S=10,step=10,tmax=1e4)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
ecovirtual
Ecovirtual
EcoVirtual
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
install.packages("/home/melina/SVN_PI/ecovirtual/RcmdrPlugin.EcoVirtual_0.01.tar.gz" ,repos=NULL) # VAIO new
install.packages("/home/melina/SVN/ecovirtual/RcmdrPlugin.EcoVirtual_0.01.tar.gz" ,repos=NULL) # VAIO new
detach("package:Rcmdr", unload=TRUE)
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
simHub2=function(S= 100, j=10, D=1, cicles=1e4, step, m=0.01, anima=TRUE)
{
if(cicles<200){cicles=200; cat("\n Minimum number of cicles: 200\n")}
stepseq=round(seq(101, cicles+1, len=100))
step=stepseq[2]- stepseq[1]
## Tamanho da comunidade
J <- S*j
##Matrizes para guardar os resultados
## matriz da especie de cada individuo por ciclo
ind.mat=matrix(nrow=J,ncol=100+length(stepseq))
##CONDICOES INICIAIS##
## Todas as especies comecam com o meamo numero de individuos (j=J/S)
## Rotulo de especies para cada um dos inividuos
ind.mat[,1] <- rep(1:S,each=j)
## Repetindo este rotulo no vetor que sofrera modificacoes
cod.sp <- ind.mat[,1]
####################################
#### primeiras 100 simulacoes  #####
####################################
for(k in 2:100)
{
##Indice dos individuos que morrem
morte <- sample(1:J,D)
## Indice dos individuos mortos que serao repostos por migrantes
defora <- sample(c(TRUE,FALSE),size=D,replace=TRUE,prob=c(m,1-m))
##Indice dos individuos que produzem filhotes para substituir os mortos
novosd <- sample(1:J,D-sum(defora),replace=TRUE)
novosf <- sample(1:J,sum(defora),replace=TRUE)
##Substituindo
## Mortos por propagulos de dentro
if(length(novosd)>0){
cod.sp[morte[!defora]]<-cod.sp[novosd]
}
## Mortos por propagulos de fora
if(length(novosf)>0){
cod.sp[morte[defora]]<-ind.mat[,1][novosf]
}
## A cada step ciclos os resultados sao gravados
ind.mat[,k] <- cod.sp
}
#####################################################
cont=100
##Aqui comecam as simulacoes
for(i in 1:length(stepseq)){
cont=cont+1
for(j in 1:step)
{
##Indice dos individuos que morrem
morte <- sample(1:J,D)
## Indice dos individuos mortos que serao repostos por migrantes
defora <- sample(c(TRUE,FALSE),size=D,replace=TRUE,prob=c(m,1-m))
##Indice dos individuos que produzem filhotes para substituir os mortos
novosd <- sample(1:J,D-sum(defora),replace=TRUE)
novosf <- sample(1:J,sum(defora),replace=TRUE)
##Substituindo
## Mortos por propagulos de dentro
if(length(novosd)>0){
cod.sp[morte[!defora]]<-cod.sp[novosd]
}
## Mortos por propagulos de fora
if(length(novosf)>0){
cod.sp[morte[defora]]<-ind.mat[,1][novosf]
}
}
## A cada step ciclos os resultados sao gravados
ind.mat[,cont] <- cod.sp
}
tempo <- c(0:99,stepseq)
colnames(ind.mat) <- tempo
x11()
if(anima==TRUE)
{
animaHub(dadoHub=ind.mat)
}
########### grafico interno ###############
x11()
plot(tempo,apply(ind.mat,2,rich), xlab="Time (cicles)", ylab="Number of species", type="l",
main="Neutral Dynamics - Original Community Colonization",sub=paste( "S=",S," J=",J," m=",m,"Mean Extintion rate =",(S-rich(ind.mat[,ncol(ind.mat)]))/cicles,"sp/cicle"),ylim=c(0,S), cex.sub=0.7)
invisible(ind.mat)
}
simHub2(j=2,cicles=2e4,m=0.1)
animaHub=function(dadoHub, sleep=0.1)
{
library(tcltk)
#nsp=length(unique(dadoHub[,1]))
maxsp=max(dadoHub)[1]
uniqsp=unique(as.numeric(dadoHub))
nind=dim(dadoHub)[1]
#nindsp=table(dadoHub[,1])[[1]]
nsim=dim(dadoHub)[2]
ciclo=as.numeric(colnames(dadoHub))
pb = tkProgressBar(title = "Simulation Progress", max = nsim)
riq=apply(dadoHub, 2, rich)
## definindo o tamanho do retangulo
lado<-round(sqrt(nind))
lado2<-ceiling(nind/lado)
lastLine=lado*lado2 - nind
cormix=sample(rainbow(maxsp+10))
#if(lastLine !=0){cor=c("#000000", cor)}
#ffffff
cor=c("#FFFFFF", cormix)
mcor<-c("#FFFFFF00","#000000")
spcol<-c(rep(0, lastLine),dadoHub[,1])
############ escala das especies da metapopulacao ########
layout(matrix(data=c(2,1), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(2,2,1,2))
image(x=1:maxsp, y=1, matrix(data=1:maxsp, nrow=maxsp,ncol=1),col=rainbow(maxsp), ylab="",xlab="", xaxt="n", yaxt="n", main="Metacommunity Species colors", cex.main=0.8)
axis(3, at = c(1,maxsp), labels = c(1, maxsp), tick = FALSE, mgp=c(1,0,0), cex.axis=0.8)
hmat=matrix(spcol,ncol=lado, nrow=lado2)
#cormat=matrix(cor[factor(spcol, levels=0:maxsp)], ncol=lado, nrow=lado2)
par(mar=c(2,2,2,2))
image(hmat, col=cor[sort(unique(as.numeric(hmat)))], xaxt="n", yaxt="n")
#mtext(text="simulation ", side=1, adj=0)
grid(nx=lado2, ny=lado)
#mtext(text="                   1", side=1, col="white",adj=0)
for (i in 2:nsim)
{
#if(riq[i]==1){cor=cor[unique(dadoHub[,i])[1]]}
#	mtext(text=paste("                    ", ciclo[i-1]), side=1, col="white", adj=0)
mvf=dadoHub[,i-1]!=dadoHub[,i]
matm<-matrix(c(rep(FALSE, lastLine),mvf ),ncol=lado, nrow=lado2)
image(matm,col=mcor, add=TRUE)
Sys.sleep(sleep)
spcol<-c(rep(0, lastLine),dadoHub[,i] )
cores=cor[sort(unique(spcol)+1)]
scol<-sort(unique(spcol))
lcol<-length(scol)
mcol<-match(spcol, scol)
hmat=(matrix(mcol,ncol=lado, nrow=lado2))
image(hmat, col=cores, add=TRUE)
grid(nx=lado2, ny=lado)
#	mtext(text=paste("                    ", ciclo[i]), side=1, adj=0)
setTkProgressBar(pb, value = i, label = paste("Simulation #", ciclo[i], sep=""))
}
close(pb)
}
simHub2(j=2,cicles=2e4,m=0.1)
simHub2=function(S= 100, j=10, D=1, cicles=1e4, m=0.01, anima=TRUE)
{
if(cicles<200){cicles=200; cat("\n Minimum number of cicles: 200\n")}
stepseq=round(seq(101, cicles+1, len=100))
step=stepseq[2]- stepseq[1]
## Tamanho da comunidade
J <- S*j
##Matrizes para guardar os resultados
## matriz da especie de cada individuo por ciclo
ind.mat=matrix(nrow=J,ncol=100+length(stepseq))
##CONDICOES INICIAIS##
## Todas as especies comecam com o meamo numero de individuos (j=J/S)
## Rotulo de especies para cada um dos inividuos
ind.mat[,1] <- rep(1:S,each=j)
## Repetindo este rotulo no vetor que sofrera modificacoes
cod.sp <- ind.mat[,1]
####################################
#### primeiras 100 simulacoes  #####
####################################
for(k in 2:100)
{
##Indice dos individuos que morrem
morte <- sample(1:J,D)
## Indice dos individuos mortos que serao repostos por migrantes
defora <- sample(c(TRUE,FALSE),size=D,replace=TRUE,prob=c(m,1-m))
##Indice dos individuos que produzem filhotes para substituir os mortos
novosd <- sample(1:J,D-sum(defora),replace=TRUE)
novosf <- sample(1:J,sum(defora),replace=TRUE)
##Substituindo
## Mortos por propagulos de dentro
if(length(novosd)>0){
cod.sp[morte[!defora]]<-cod.sp[novosd]
}
## Mortos por propagulos de fora
if(length(novosf)>0){
cod.sp[morte[defora]]<-ind.mat[,1][novosf]
}
## A cada step ciclos os resultados sao gravados
ind.mat[,k] <- cod.sp
}
#####################################################
cont=100
##Aqui comecam as simulacoes
for(i in 1:length(stepseq)){
cont=cont+1
for(j in 1:step)
{
##Indice dos individuos que morrem
morte <- sample(1:J,D)
## Indice dos individuos mortos que serao repostos por migrantes
defora <- sample(c(TRUE,FALSE),size=D,replace=TRUE,prob=c(m,1-m))
##Indice dos individuos que produzem filhotes para substituir os mortos
novosd <- sample(1:J,D-sum(defora),replace=TRUE)
novosf <- sample(1:J,sum(defora),replace=TRUE)
##Substituindo
## Mortos por propagulos de dentro
if(length(novosd)>0){
cod.sp[morte[!defora]]<-cod.sp[novosd]
}
## Mortos por propagulos de fora
if(length(novosf)>0){
cod.sp[morte[defora]]<-ind.mat[,1][novosf]
}
}
## A cada step ciclos os resultados sao gravados
ind.mat[,cont] <- cod.sp
}
tempo <- c(0:99,stepseq)
colnames(ind.mat) <- tempo
x11()
if(anima==TRUE)
{
animaHub(dadoHub=ind.mat)
}
########### grafico interno ###############
x11()
plot(tempo,apply(ind.mat,2,rich), xlab="Time (cicles)", ylab="Number of species", type="l",
main="Neutral Dynamics - Original Community Colonization",sub=paste( "S=",S," J=",J," m=",m,"Mean Extintion rate =",(S-rich(ind.mat[,ncol(ind.mat)]))/cicles,"sp/cicle"),ylim=c(0,S), cex.sub=0.7)
invisible(ind.mat)
}
simHub2(j=2,cicles=2e4,m=0.1)
sucMatrix=function(mat.trans, init.prop, rw, cl, tmax)
{
mat.trans=as.matrix(mat.trans)
porc1=apply(mat.trans,2,sum)
if(sum(porc1!=1)>0)
{
stop("the transition for each fase should sum 1: there is no extintion of area under the model")
}
if(sum(init.prop)!=1 | lenmatgth(init.prop) != dim(mat.trans)[2])
{
stop("the initial proportion of ocupance should sum 1 and the number of stages should be iqual to transition matrix")
}
nfase=dim(mat.trans)[1]
ncel=rw*cl
fase_n=round(init.prop*ncel)
cl_fase=colorRampPalette(c("gray","yellow", "orange","green"))
#cores=c("#ffffff",colors(nfase-1))
#cores=terrain.colors(nfase)
arena=matrix(NA,nrow=rw,ncol=cl)
#resulta=matrix(0,ncol=nfase, nrow=tmax)
pais=array(0,dim=c(rw, cl, tmax))
#image(0:rw,0:cl, matrix(0,nrow=rw,ncol=cl), col="white", xlab="", ylab="")
#grid(rw,cl)
n0=sample(rep(0:(nfase-1), fase_n))
arena[1:ncel]<-n0
#t.n0=table(n0)
#resulta[1,as.numeric(names(t.n0))+1]<-t.n0
pais[,,1]<-arena
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Sucessional Model")
grid(rw,cl)
for (tc in 2:tmax)
{
for(nf in 0:(nfase-1))
{
nf_vf=pais[,,(tc-1)]==nf
contn=sum(nf_vf)
pais[,,tc][nf_vf]<-sample(0:(nfase-1),contn,replace=TRUE, prob=as.numeric(mat.trans[,(nf+1)]))
}
#          resulta[tc,as.numeric(names(t_n0))+1]<-t_n0
image(0:rw, 0:cl, pais[,,tc], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), add=TRUE)
Sys.sleep(.1)
}
x11()
op=par(mfrow=c(2,2))
image(0:rw, 0:cl, arena, col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), xlab="", ylab="", main="Ernitial Conditions")
for(ts in c(4,2,1))
{
image(0:rw, 0:cl, pais[,,round(tc/ts)], col=cl_fase(nfase) , breaks=c(-0.1,(1:nfase)-0.1), main=paste("Cicle", round(tc/ts)))
}
par(op)
x11()
resulta=t(apply(pais,3, table))
matplot(resulta, type="l", ylim=c(min(resulta)*0.8, max(resulta)*1.1), main="Stage Distribution",xlab="Number of patchs", col=cl_fase(nfase), lty=2, lwd=2)
legend("topright", legend=paste("Stage", 1:nfase), lty=2, lwd=2, col=cl_fase(nfase), bty="n", cex=0.8)
#resulta=as.data.frame(resulta)
eigs_st=eigen(mat.trans)
dom_pos=which.max(Re(eigs_st$values))
stage_v<- Re(eigs_st[["vectors"]][, dom_pos])
stage_stable=(stage_v/sum(stage_v))*ncel
abline(h=stage_stable, col=cl_fase(nfase), lwd=0.8)
legend("topleft", legend=paste("Stage Stable", 1:nfase), lty=1, lwd=0.9, col=cl_fase(nfase), bty="n", cex=0.8)
invisible(pais)
}
ec
dst
er
sc
mx
rs
regNicho=function(tmax, rw, cl, c1,c2, ec, dst,  er, sc, mx, rs)
{
N=cl*rw
V=1-er-sc-mx-rs
cena=array(NA,dim=c(rw,cl,tmax))
cena[,,1]<-sample(c(0:4), N, prob=c(V,er,sc,mx, rs), replace=TRUE)
resulta=matrix(0, ncol=5, nrow = tmax)
conta=table(cena[,,1])/N
resulta[1,(as.numeric(names(conta))+1)]<-conta
for (t in 2:tmax)
{
Vvf<-cena[,,t-1]==0
nV=sum(Vvf)
ervf<-cena[,,t-1]==1
ner=sum(ervf)
scvf<-cena[,,t-1]==2
nsc=sum(scvf)
mxvf<-cena[,,t-1]==3
nmx=sum(mxvf)
rsvf<-cena[,,t-1]==4
nrs=sum(rsvf)
p_col1=c1*(nsc+nmx+nrs)/N
p_col2=c2*(ner+nmx)/N
p_ncol=1-p_col1- p_col2
p_permer = 1- (dst + p_col1)
p_permsc = 1- (dst + p_col2 + ec)
p_permmx = 1 - (dst + ec)
if(p_ncol<0){p_ncol=0}
if(p_permer<0){p_permer=0}
if(p_permsc<0){p_permsc=0}
if(p_permmx<0){p_permmx=0}
cena[,,t][Vvf]<-sample(c(0,1,2),nV, replace=TRUE, prob=c(p_ncol,p_col2,p_col1))
cena[,,t][ervf]<-sample(c(0,1,3), ner, replace=TRUE, prob=c(dst,p_permer , p_col1))
cena[,,t][scvf]<-sample(c(0,2,3,4), nsc, replace=TRUE, prob=c(dst,p_permsc, p_col2, ec))
cena[,,t][mxvf]<-sample(c(0,3,4), nmx, replace=TRUE, prob=c(dst,p_permmx, ec))
cena[,,t][rsvf]<-sample(c(0,4), nrs, replace=TRUE, prob=c(dst,1 - dst))
conta=table(cena[,,t])/N
resulta[t,(as.numeric(names(conta))+1)]<-conta
}
animaCena(cena)
x11()
matplot( 1:tmax,resulta[,2:5], type="l", main="Niche Regeneration Model" , xlab="time", ylab="State proportion", lty=2:5, col=2:5)
legend("topright", c("Early", "Susceptible", "Mixed", "Resistant"), bty="n", lty=2:5, col=2:5, cex=0.7)
invisible(cena)
}
#regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
regNicho(tmax=50, rw=100, cl=100, c1=0.2, c2=0.8, ec=0.5, dst=0.04,  er=0.08, sc=0.02, mx=0, rs=0)
crescLog=function(N0, r, K, tmax)
{
resulta=matrix(rep(NA,3*tmax),ncol=3)
colnames(resulta)=c("time", "Continuous Model ", "Discrete Model")
resulta[,1]=seq(0,(tmax-1))
resulta[1,2:3]=N0
for(t in 2:tmax)
{
#cat("t= ", t-1,"\n")
resulta[t,2]=K/(1+((K-N0)/N0)*exp(-r*(t-1)))
lastN=resulta[t-1,3]
resulta[t,3]=lastN+r*lastN*(1-lastN/K)
}
x11()
plot(resulta[,1],resulta[,2],type="l", lty=2,ylim=c(min(resulta[,c(2,3)])*0.8, K*1.2), xlab="Time (t)", main="Logistic Population Growth", ylab="Population size (N)", sub=paste("Intrinsic rate (r) =", r, sep=""))
lines(resulta[,1],resulta[,3], col="red")
legend("bottomright", colnames(resulta)[2:3],lty=2,col=c(1,2),bty="n")
abline(h=K, lty=3, col="blue")
text(x=2, y=K, "Carying capacity", col="blue",adj=c(0,0))
text(x=tmax*0.5, y= resulta[(tmax/2),2], paste("r=", r),pos=3)
invisible(resulta)
}
crescLog(N0=10, r=0.05, K=80, tmax=100)
crescLog=function(N0, r, K, tmax)
{
resulta=matrix(rep(NA,3*tmax),ncol=3)
colnames(resulta)=c("time", "Continuous Model ", "Discrete Model")
resulta[,1]=seq(0,(tmax-1))
resulta[1,2:3]=N0
for(t in 2:tmax)
{
#cat("t= ", t-1,"\n")
resulta[t,2]=K/(1+((K-N0)/N0)*exp(-r*(t-1)))
lastN=resulta[t-1,3]
resulta[t,3]=lastN+r*lastN*(1-lastN/K)
}
x11()
plot(resulta[,1],resulta[,2],type="l", lty=2,ylim=c(min(resulta[,c(2,3)])*0.8, K*1.2), xlab="Time (t)", main="Logistic Population Growth", ylab="Population size (N)", r, sep=""))
lines(resulta[,1],resulta[,3], col="red")
legend("bottomright", colnames(resulta)[2:3],lty=2,col=c(1,2),bty="n")
abline(h=K, lty=3, col="blue")
text(x=2, y=K, "Carying capacity", col="blue",adj=c(0,0))
text(x=tmax*0.5, y= resulta[(tmax/2),2], paste("r=", r),pos=3)
invisible(resulta)
}
crescLog=function(N0, r, K, tmax)
{
resulta=matrix(rep(NA,3*tmax),ncol=3)
colnames(resulta)=c("time", "Continuous Model ", "Discrete Model")
resulta[,1]=seq(0,(tmax-1))
resulta[1,2:3]=N0
for(t in 2:tmax)
{
#cat("t= ", t-1,"\n")
resulta[t,2]=K/(1+((K-N0)/N0)*exp(-r*(t-1)))
lastN=resulta[t-1,3]
resulta[t,3]=lastN+r*lastN*(1-lastN/K)
}
x11()
plot(resulta[,1],resulta[,2],type="l", lty=2,ylim=c(min(resulta[,c(2,3)])*0.8, K*1.2), xlab="Time (t)", main="Logistic Population Growth", ylab="Population size (N)", sub=paste("Intrinsic rate (r) =", r, sep=""))
lines(resulta[,1],resulta[,3], col="red")
legend("bottomright", colnames(resulta)[2:3],lty=2,col=c(1,2),bty="n")
abline(h=K, lty=3, col="blue")
text(x=2, y=K, "Carying capacity", col="blue",adj=c(0,0))
text(x=tmax*0.5, y= resulta[(tmax/2),2], paste("r=", r),pos=3)
invisible(resulta)
}
crescLog=function(N0, r, K, tmax)
{
resulta=matrix(rep(NA,3*tmax),ncol=3)
colnames(resulta)=c("time", "Continuous Model ", "Discrete Model")
resulta[,1]=seq(0,(tmax-1))
resulta[1,2:3]=N0
for(t in 2:tmax)
{
#cat("t= ", t-1,"\n")
resulta[t,2]=K/(1+((K-N0)/N0)*exp(-r*(t-1)))
lastN=resulta[t-1,3]
resulta[t,3]=lastN+r*lastN*(1-lastN/K)
}
x11()
plot(resulta[,1],resulta[,2],type="l", lty=2,ylim=c(min(resulta[,c(2,3)])*0.8, K*1.2), xlab="Time (t)", main="Logistic Population Growth", ylab="Population size (N)", sep=""))
lines(resulta[,1],resulta[,3], col="red")
legend("bottomright", colnames(resulta)[2:3],lty=2,col=c(1,2),bty="n")
abline(h=K, lty=3, col="blue")
text(x=2, y=K, "Carying capacity", col="blue",adj=c(0,0))
text(x=tmax*0.5, y= resulta[(tmax/2),2], paste("r=", r),pos=3)
invisible(resulta)
}
crescLog=function(N0, r, K, tmax)
{
resulta=matrix(rep(NA,3*tmax),ncol=3)
colnames(resulta)=c("time", "Continuous Model ", "Discrete Model")
resulta[,1]=seq(0,(tmax-1))
resulta[1,2:3]=N0
for(t in 2:tmax)
{
#cat("t= ", t-1,"\n")
resulta[t,2]=K/(1+((K-N0)/N0)*exp(-r*(t-1)))
lastN=resulta[t-1,3]
resulta[t,3]=lastN+r*lastN*(1-lastN/K)
}
x11()
plot(resulta[,1],resulta[,2],type="l", lty=2,ylim=c(min(resulta[,c(2,3)])*0.8, K*1.2), xlab="Time (t)", main="Logistic Population Growth", ylab="Population size (N)")
lines(resulta[,1],resulta[,3], col="red")
legend("bottomright", colnames(resulta)[2:3],lty=2,col=c(1,2),bty="n")
abline(h=K, lty=3, col="blue")
text(x=2, y=K, "Carying capacity", col="blue",adj=c(0,0))
text(x=tmax*0.5, y= resulta[(tmax/2),2], paste("r=", r),pos=3)
invisible(resulta)
}
crescLog(N0=10, r=0.05, K=80, tmax=100)
crescLog(N0=10, r=0.005, K=80, tmax=100)
matrix(rep(NA,3*tmax),ncol=3)
tmax=100
matrix(rep(NA,3*tmax),ncol=3)
crescLog(N0=10, r=0.5, K=80, tmax=100)
crescLog(N0=10, r=0.3, K=80, tmax=100)
crescLog(N0=10, r=0.10, K=80, tmax=100)
