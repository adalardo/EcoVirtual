#	image(0:ln,0:cl, matrix(0,nrow=ln,ncol=cl), col="white", xlab="", ylab="", add=TRUE)
#	#text(ln/2, cl/2, "EXTINTION", col="red", cex=4)
#	grid(ln,cl)
#	stop()
#	}
image(0:ln,0:cl, matrix(0,nrow=ln,ncol=cl), col="white", xlab="", ylab="", add=TRUE)
image(0:ln, 0:cl, pais[,,tc], col=c("white", "green", "darkgreen") ,breaks=c(0,1,2,3), xlab="", ylab="",  add=TRUE, sub=paste("simulation no. =",tc ))
grid(ln,cl)
xsem=sample(seq(0,cl,0.1), n.fec, replace=TRUE)
ysem=sample(seq(0,ln,0.1), n.fec, replace=TRUE)
xy.sem[[2]]=cbind(x=xsem,y=ysem)
ind.sem=floor(ysem)*cl + ceiling(xsem)
points(xsem,ysem, col="red", pch=16)
Sys.sleep(.1)
t.fr=table(pais[,,tc])
tab.fr[tc,as.numeric(names(t.fr))+1]<-t.fr[]
tab.fr[tc,2]<-n.fec
}
tab.rel=tab.fr/apply(tab.fr,1,sum)
names(tab.rel)<-c("Empty", "Seed", "Juvenil", "Adult")
x11()
matplot(tab.rel, type="l",col=c("gray", "red", "green", "darkgreen"),lwd=2,main= "Stage Frequency", ylab="Frequency", xlab="Time (t)")
legend("topright",legend=c("Empty", "Seed", "Juvenil", "Adult") ,lty=1:4, col=c("gray", "red", "green", "darkgreen"), bty="n", cex=0.8 )
#t.sim=apply(pais,3, table)
invisible(list(simula=pais, xy=xy.sem))
}
popStr(p.sj=0.05, p.jj=0.99, p.ja=0, p.aa=1, fec=1.2, ns=100,nj=150,na=50, ln=20, cl=20, tmax=100)
metaCiEr <-function(tf,cl,ln,fi,i,e)
{
nmanchas=cl*ln
paisag=array(0,dim=c(ln,cl,tf))
paisag[,,1]=sample(c(rep(0,round(nmanchas-fi*nmanchas)),rep(1,round(fi*nmanchas))))
resultado=numeric()
rese=numeric()
resi=numeric()
for(tc in 2:tf)
{
pe=e*(1-(sum(paisag[,,tc-1])/nmanchas))
pc=i*sum(paisag[,,tc-1])/nmanchas
paisag[,,tc][paisag[,,(tc-1)]==1]<-sample(c(0,1),sum(paisag[,,tc-1]),replace=TRUE,prob=c(pe,1-pe))
paisag[,,tc][paisag[,,(tc-1)]==0]<-sample(c(0,1),nmanchas-sum(paisag[,,tc-1]),replace=TRUE,prob=c(1-pc,pc))
resultado[tc-1]=sum(paisag[,,tc])/nmanchas
rese[tc-1]=pe
resi[tc-1]=pc
}
x11()
animaMeta2(paisag)
x11()
grFim(paisag)
x11()
plot(1:tf,c(fi,resultado),type="l",xlab="Time",ylab="Occupancy proportion", ylim=c(0,1),main=paste("Propagulus Rain and Internal colonization and Rescue Effect","\n cols=",cl," rows=",ln," fi=",fi," i=",i, "e=",e),font.lab=2,lwd=2)
abline(h=0,lty=2)
points(1:tf,c(e*(1-fi),rese),type='l',lwd=2,col=4,lty=3)
points(1:tf,c(i*fi,resi),type='l',lwd=2,col=6,lty=3)
legend("topright", legend=c("patchs occupance", "colonization", "extintion"), lty=c(1,3,3), col=c(1,6,4), bty="n")
return(paisag)
}
metaCiEr(100,10,10,0.5,0.5,0.5)
animaMeta2=function(dados)
{
nsim=dim(dados)[3]
ln=dim(dados)[1]
cl=dim(dados)[2]
image(0:ln, 0:cl, dados[,,1], col=c("white", "green") , breaks=c(0,0.99,5),main="Metapopulation Dynamics", sub=paste("Initial configuration from", nsim," simulations",  sep=""), xlab="", ylab="")
grid(ln,cl)
Sys.sleep(.5)
conta12=dados[,,1]+ (2*dados[,,2])
image(0:ln, 0:cl, conta12, col=c("white","red","lightgreen", "darkgreen") , breaks=c(0,0.9,1.9,2.9,3.9),main="Metapopulation Dynamics", sub=paste("red= extintion; light green= colonization; dark green = permanence \n maximum time = ", nsim, sep=""), xlab="", ylab="")
for(i in 3:nsim)
{
conta12=dados[,,(i-1)]+ (2*dados[,,i])
image(0:ln, 0:cl, conta12, col=c("white","red","lightgreen", "darkgreen") , breaks=c(0,0.9,1.9,2.9,3.9), xlab="", ylab="", add=TRUE)
Sys.sleep(.1)
}
}
## grFim used in 'metaPop', 'metaEr', 'metaCi', 'metaCier'
grFim=function(dados)
{
op=par(mfrow=c(2,2))
nsim=dim(dados)[3]
ln=dim(dados)[1]
cl=dim(dados)[2]
image(0:ln, 0:cl, dados[,,1], col=c("white", "green") , breaks=c(0,0.99,5),main="Metapopulation Dynamics", sub=paste("time = 1/", nsim, sep=""), xlab="", ylab="")
grid(ln,cl)
for(ts in c(4,2,1))
{
sim=round(nsim/ts)
conta12=dados[,,(sim-1)]+ (2*dados[,,sim])
image(0:ln, 0:cl, conta12, col=c("white","red","lightgreen", "darkgreen") , breaks=c(0,0.9,1.9,2.9,3.9),main="Metapopulation Dynamics", sub=paste("red= extintion; light green= colonization;\n dark green = permanence \t time = ", sim, "/", nsim, sep=""), xlab="", ylab="")
#	Sys.sleep(.5)
}
par(op)
}
metaCiEr(100,10,10,0.5,0.5,0.5)
metaCiEr <-function(tf,cl,ln,fi,i,e)
{
nmanchas=cl*ln
paisag=array(0,dim=c(ln,cl,tf))
paisag[,,1]=sample(c(rep(0,round(nmanchas-fi*nmanchas)),rep(1,round(fi*nmanchas))))
resultado=numeric()
rese=numeric()
resi=numeric()
for(tc in 2:tf)
{
pe=e*(1-(sum(paisag[,,tc-1])/nmanchas))
pc=i*sum(paisag[,,tc-1])/nmanchas
paisag[,,tc][paisag[,,(tc-1)]==1]<-sample(c(0,1),sum(paisag[,,tc-1]),replace=TRUE,prob=c(pe,1-pe))
paisag[,,tc][paisag[,,(tc-1)]==0]<-sample(c(0,1),nmanchas-sum(paisag[,,tc-1]),replace=TRUE,prob=c(1-pc,pc))
resultado[tc-1]=sum(paisag[,,tc])/nmanchas
rese[tc-1]=pe
resi[tc-1]=pc
}
x11()
animaMeta2(paisag)
grFim(paisag)
x11()
plot(1:tf,c(fi,resultado),type="l",xlab="Time",ylab="Occupancy proportion", ylim=c(0,1),main=paste("Propagulus Rain and Internal colonization and Rescue Effect","\n cols=",cl," rows=",ln," fi=",fi," i=",i, "e=",e),font.lab=2,lwd=2)
abline(h=0,lty=2)
points(1:tf,c(e*(1-fi),rese),type='l',lwd=2,col=4,lty=3)
points(1:tf,c(i*fi,resi),type='l',lwd=2,col=6,lty=3)
legend("topright", legend=c("patchs occupance", "colonization", "extintion"), lty=c(1,3,3), col=c(1,6,4), bty="n")
invisible(paisag)
}
metaCiEr(100,10,10,0.5,0.5,0.5)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
detach("package:EcoVirtual", unload=TRUE)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
simHub1(S=10,j=10, D=1, ciclo=5e3, anima=FALSE)
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
detach("package:Rcmdr", unload=TRUE)
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
a
ar
tmax
minar
arquip=function(n.isl,ar.min, ar.max, Nspp, seed.rain, abund, tmax, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
#lado.isl=sqrt(ar.isl)
spp=1:Nspp
cena=array(0, dim=c(Nspp,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==Nspp) {abund=abund/sum(abund)}else{
cat("\n valores de abundância não correspondem ao número de espécie, apenas o primeiro valor foi considerado\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/Nspp, Nspp);cat("\n distribuição equitativa de abundância\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:Nspp)-1); cat("\n modelo de distribuição geometrica de abundância\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
#		nsemIlh=function(x,y,...){comp.isl<=x & comp.ils}
#		outer(loc.x, loc.y, sum  )
#v.x=loc.x<ar.isl[l]
#v.y=loc.y<ar.isl[l]
#v.spp=unique(chuva[v.x & v.y])
#cena[v.spp,l,1]<-1
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
#		if(i>1 & anima==TRUE)
#		animaIsl(cena[,,i],ar.isl, Nspp, loc.x, loc.y, chuva,i)
}
riq.tempo=t(apply(cena, c(2,3), sum))
x11()
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("Nº Islands=",n.isl,"; Nº spp=",Nspp,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Species Number", ylab="Colonization (species/cicle)", cex.axis=1.2, main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
detach("package:EcoVirtual", unload=TRUE)
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
detach("package:Rcmdr", unload=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, Nspp=1000, seed.rain=100, abund=10, tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, Nspp=1000, seed.rain=100, abund=rep(10,1000) tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, Nspp=1000, seed.rain=100, abund=rep(10,1000), tmax=100, anima=TRUE)
arquip=function(n.isl,ar.min, ar.max, S, seed.rain, abund, tmax, anima=TRUE)
{
ar.ampl=ar.max -ar.min
ar.isl= seq(ar.min, ar.max, length.out=n.isl)
#lado.isl=sqrt(ar.isl)
spp=1:S
cena=array(0, dim=c(S,n.isl, tmax))
local=seq(0, ar.max , len=n.isl*10)
local[c(1,n.isl*10)]=local[c(2, n.isl*10-1)]
locxy<-list()
sprain<-list()
if(length(abund)==S) {abund=abund/sum(abund)}else{
cat("\n valores de abundância não correspondem ao número de espécie, apenas o primeiro valor foi considerado\n")
abund=abund[1]
if(abund==0 | abund>=1){abund=rep(1/S, S);cat("\n distribuição equitativa de abundância\n")}else{
if(abund<=1 & abund>0){abund = abund*(1-abund)^((1:S)-1); cat("\n modelo de distribuição geometrica de abundância\n")}
}
}## modelo tilman geometrico ## todas especies igualmente contribuem para a chuva
for(i in 2:tmax)
{
cena[,,i]<-cena[,,(i-1)]
chuva=sample(spp, seed.rain, prob=abund, replace=TRUE)
loc.x=sample(local, seed.rain, replace=TRUE)
loc.y=sample(local, seed.rain, replace=TRUE)
#		nsemIlh=function(x,y,...){comp.isl<=x & comp.ils}
#		outer(loc.x, loc.y, sum  )
#v.x=loc.x<ar.isl[l]
#v.y=loc.y<ar.isl[l]
#v.spp=unique(chuva[v.x & v.y])
#cena[v.spp,l,1]<-1
locxy[[i]]<-cbind(loc.x, loc.y)
sprain[[i]]<-chuva
for(l in 1:n.isl)
{
v_x=loc.x<=ar.isl[l]
v_y=loc.y<=ar.isl[l]
v_spp=unique(chuva[v_x & v_y])
cena[v_spp,l,i]<-1
}
#		if(i>1 & anima==TRUE)
#		animaIsl(cena[,,i],ar.isl, S, loc.x, loc.y, chuva,i)
}
riq.tempo=t(apply(cena, c(2,3), sum))
x11()
if(i>1 & anima==TRUE)
{
animaIsl(riq.tempo, ar.isl, locxy, sprain)
}
x11()
layout(matrix(data=c(1,2), nrow=2, ncol=1), widths=c(1,1), heights=c(5,1))
old<-par(mar=c(5,4,3,3))#, oma=c(0,0,0,0))
matplot(riq.tempo, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Time", ylab="Number of Species", cex.axis=1.2, main="Passive Colonization", cex.main=1.2 )
par(mar=c(2,2,1,2))
image(x=1:n.isl, y=1, matrix(data=1:n.isl, nrow=n.isl,ncol=1),col=rainbow(n.isl), ylab="",xlab="", xaxt="n", yaxt="n", main="Island Size (Area)", cex.main=0.8)
pos.x=1:(n.isl)
area.isl=round(ar.isl^2,0)
axis(1,at=pos.x, area.isl, cex.axis=0.8)
x11()
par(mfrow=c(2,1))
riq.final<-riq.tempo[tmax,]
mod1<-lm(log10(riq.final)~log10(area.isl))
plot(area.isl,riq.final,log="xy",pch=16,col=rainbow(n.isl),bty="l",main=paste("Nº Islands=",n.isl,"; Nº spp=",S,"; Time=",tmax), sub=paste("c=",round(10^coef(mod1)[1],2),"; z=",round(coef(mod1)[2],2)),xlab="Island Area",ylab="Number of species",ylim=c(1,max(riq.final)))
abline(mod1, lty=2)
rqz<-apply(cena, c(2,3), sum)
clz<-diff(riq.tempo)
matplot(riq.tempo[2:100,],clz, type="l", col=rainbow(n.isl), bty="l", cex.lab=1.2, xlab="Species Number", ylab="Colonization (species/cicle)", cex.axis=1.2, main="Colonization Rate Curves", cex.main=1.2 )
invisible(cena)
}
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=rep(10,1000), tmax=100, anima=TRUE)
arquip(n.isl=10,ar.min=10, ar.max=100, S=1000, seed.rain=100, abund=0.5, tmax=100, anima=TRUE)
animaColExt=function(min=0.01, max=1, cicles=100, ext="crs", col="dcr")
a=seq(from=min,to=max,length.out=cicles)
b=seq(from=max, to=min, length.out=cicles)
nt=length(a)
if(ext=="fix"){ext=rep(0.5,nt)}
if(ext=="crs"){ext=a}
if(ext=="dcr"){ext=b}
if(col=="fix"){col=rep(0.5,nt)}
if(col=="crs"){col=a}
if(col=="dcr"){col=b}
x11()
grColExt(E=ext,I=col,P=100, areas=1)
}
animaColExt=function(min=0.01, max=1, cicles=100, ext="crs", col="dcr")
{
a=seq(from=min,to=max,length.out=cicles)
b=seq(from=max, to=min, length.out=cicles)
nt=length(a)
if(ext=="fix"){ext=rep(0.5,nt)}
if(ext=="crs"){ext=a}
if(ext=="dcr"){ext=b}
if(col=="fix"){col=rep(0.5,nt)}
if(col=="crs"){col=a}
if(col=="dcr"){col=b}
x11()
grColExt(E=ext,I=col,P=100, areas=1)
}
grColExt=function(E , I , P, areas)
{
S = I*P/(I+E) ; T = I*E/(I+E)
nIsl=length(E)
corIsl=rainbow(nIsl)
curve(I[1]-I[1]*x/P[1],0,P[1],bty="n",xlab="Number of Species", ylab="Rate",xaxt="n",yaxt="n", font.lab=2,lwd=2,ylim=c(0,1),  main="Island Biogeography", col=corIsl[1])
curve((E[1]/P[1])*x,0,P,lwd=2,add=TRUE, col=corIsl[1], lty=2) #xlim=c(0,1),
legend("top", legend=c("Colonization", "Extinction"),  bty="n",lty=c(1,2))
abline(v=0)
abline(h=0)
mtext("St",side=1,at=P,font=2, line=1)
linhas=seq(0,1.5, length.out=nIsl)
for(i in 1:nIsl)
{
curve(I[i]-I[i]*x/P,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=1)
curve((E[i]/P)*x,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=2)
mtext(paste("S", i, sep=""),side=1,at=S[i], cex=0.8,font=2,col=corIsl[i], line=linhas[i])
mtext(paste("T", i, sep=""),side=2,at=T[i],cex=0.8,font=2,las=1,col=corIsl[i], line=linhas[i])
points(S[i],T[i],col=corIsl[i],pch=16,cex=1)
if(length(unique(areas))>1)
{
siz_ar=2 +(areas/max(areas))
points(S[i],T[i],col=corIsl[i],cex=siz_ar[i])
}
segments(S[i],T[i],S[i],0,lty=3,col=corIsl[i])
segments(S[i],T[i],0,T[i],lty=3,col=corIsl[i])
Sys.sleep(0.1)
}
#	mtext("I",side=2,at=I,font=2,las=1, line=2)
#	mtext("E",side=4,at=E,font=2,las=1)
}
animaColExt(Ext='crs', Col="dcr")
animaColExt(ext='crs', col="dcr")
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
animaColExt(ext='crs', col="dcr")
#animaColExt(Ext='crs', Col="dcr")
animaColExt(Ext='crs', Col="dcr")
animaColExt(Ext='crs', Col="dcr")
animaColExt=function(min=0.01, max=1, cicles=100, ext="crs", col="dcr")
{
a=seq(from=min,to=max,length.out=cicles)
b=seq(from=max, to=min, length.out=cicles)
nt=length(a)
if(ext=="fix"){ext=rep(0.5,nt)}
if(ext=="crs"){ext=a}
if(ext=="dcr"){ext=b}
if(col=="fix"){col=rep(0.5,nt)}
if(col=="crs"){col=a}
if(col=="dcr"){col=b}
x11()
grColExt(E=ext,I=col,P=100, areas=1)
}
grColExt=function(E , I , P, areas)
{
S = I*P/(I+E) ; T = I*E/(I+E)
nIsl=length(E)
corIsl=rainbow(nIsl)
curve(I[1]-I[1]*x/P[1],0,P[1],bty="n",xlab="Number of Species", ylab="Rate",xaxt="n",yaxt="n", font.lab=2,lwd=2,ylim=c(0,1),  main="Island Biogeography", col=corIsl[1])
curve((E[1]/P[1])*x,0,P,lwd=2,add=TRUE, col=corIsl[1], lty=2) #xlim=c(0,1),
legend("top", legend=c("Colonization", "Extinction"),  bty="n",lty=c(1,2))
abline(v=0)
abline(h=0)
mtext("St",side=1,at=P,font=2, line=1)
linhas=seq(0,1.5, length.out=nIsl)
for(i in 1:nIsl)
{
curve(I[i]-I[i]*x/P,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=1)
curve((E[i]/P)*x,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=2)
mtext(paste("S", i, sep=""),side=1,at=S[i], cex=0.8,font=2,col=corIsl[i], line=linhas[i])
mtext(paste("T", i, sep=""),side=2,at=T[i],cex=0.8,font=2,las=1,col=corIsl[i], line=linhas[i])
points(S[i],T[i],col=corIsl[i],pch=16,cex=1)
if(length(unique(areas))>1)
{
siz_ar=2 +(areas/max(areas))
points(S[i],T[i],col=corIsl[i],cex=siz_ar[i])
}
segments(S[i],T[i],S[i],0,lty=3,col=corIsl[i])
segments(S[i],T[i],0,T[i],lty=3,col=corIsl[i])
Sys.sleep(0.1)
}
#	mtext("I",side=2,at=I,font=2,las=1, line=2)
#	mtext("E",side=4,at=E,font=2,las=1)
}
animaColExt(Ext='crs', Col="dcr")
animaColExt(ext='crs', col="dcr")
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
animaColExt
animaColExt(ext='crs', col="dcr")
animaColExt(Ext='crs', Col="dcr")
animaColExt
animaColExt=function(min=0.01, max=1, cicles=100, Ext="crs", Col="dcr")
{
a=seq(from=min,to=max,length.out=cicles)
b=seq(from=max, to=min, length.out=cicles)
nt=length(a)
if(Ext=="fix"){ext=rep(0.5,nt)}
if(Ext=="crs"){ext=a}
if(Ext=="dcr"){ext=b}
if(Col=="fix"){col=rep(0.5,nt)}
if(Col=="crs"){col=a}
if(Col=="dcr"){col=b}
x11()
grColExt(E=ext,I=col,P=100, areas=1)
}
animaColExt(ext='crs', col="dcr")
detach("package:EcoVirtual", unload=TRUE)
animaColExt(Ext='crs', Col="dcr")
grColExt=function(E , I , P, areas)
{
S = I*P/(I+E) ; T = I*E/(I+E)
nIsl=length(E)
corIsl=rainbow(nIsl)
curve(I[1]-I[1]*x/P[1],0,P[1],bty="n",xlab="Number of Species", ylab="Rate",xaxt="n",yaxt="n", font.lab=2,lwd=2,ylim=c(0,1),  main="Island Biogeography", col=corIsl[1])
curve((E[1]/P[1])*x,0,P,lwd=2,add=TRUE, col=corIsl[1], lty=2) #xlim=c(0,1),
legend("top", legend=c("Colonization", "Extinction"),  bty="n",lty=c(1,2))
abline(v=0)
abline(h=0)
mtext("St",side=1,at=P,font=2, line=1)
linhas=seq(0,1.5, length.out=nIsl)
for(i in 1:nIsl)
{
curve(I[i]-I[i]*x/P,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=1)
curve((E[i]/P)*x,0,P,lwd=2,add=TRUE, col=corIsl[i], lty=2)
mtext(paste("S", i, sep=""),side=1,at=S[i], cex=0.8,font=2,col=corIsl[i], line=linhas[i])
mtext(paste("T", i, sep=""),side=2,at=T[i],cex=0.8,font=2,las=1,col=corIsl[i], line=linhas[i])
points(S[i],T[i],col=corIsl[i],pch=16,cex=1)
if(length(unique(areas))>1)
{
siz_ar=2 +(areas/max(areas))
points(S[i],T[i],col=corIsl[i],cex=siz_ar[i])
}
segments(S[i],T[i],S[i],0,lty=3,col=corIsl[i])
segments(S[i],T[i],0,T[i],lty=3,col=corIsl[i])
Sys.sleep(0.1)
}
#	mtext("I",side=2,at=I,font=2,las=1, line=2)
#	mtext("E",side=4,at=E,font=2,las=1)
}
animaColExt(Ext='crs', Col="dcr")
randWalk <- function(S=1,step=1,tmax=1e5,x1max=200, all.eq=FALSE){
cont=round(tmax/100)
sleep=0.01
if(cont>5e4){sleep=0}
if(all.eq){
x1=rep(x1max,S)
}else{
x1 <- sample(1:x1max,S,replace=TRUE)
}
results <- matrix(NA,nrow=1+tmax/cont,ncol=S)
results[1,] <- x1
X <- x1
for(i in 2:(1+tmax/cont)){
for(j in 1:cont){
X[X<=0] <- NA
X <- X +sample(c(step,-1*step),S,replace=TRUE)
}
results[i,] <- X
}
results[is.na(results)] <- 0
time <- seq(0,tmax,by=cont)
x11()
animaRandWalk(rwData=results, time= time, sleep=sleep)
invisible(results)
#  matplot(time,results,type="l", col=rainbow(S),lwd=2, xlab="Steps",  main="Randon Walk",ylab="Distance from the edge")
#  abline(h=0,lwd=4)
}
animaRandWalk = function(rwData, time=2, sleep=0.1)
{
#par( )
xplus=max(time)*0.1
ymax=max(apply(rwData, 2, max))[1]
plot(time, rwData[,which.max(apply(rwData, 2, max))[1]], xlab="Steps", ylab="Distance from the edge",cex.axis=1.2, cex.lab=1.2,ylim=c(-.1* ymax,ymax), main="Randon Walk", cex.main=1.5, type="n", xlim=c(0,max(time)))
polygon(x=c(-xplus, -xplus, max(time)+xplus, max(time)+xplus), y=c(ymax*-0.15,0,0,ymax*-0.15), col="gray")
text(max(time)/2, -0.05* ymax, labels="Absortion Surface", col="red", cex=1.5)
n=dim(rwData)[2]
#ncolors= terrain.colors(n)
ncolors= rainbow(n)
for(i in 2:length(time))
{
for(j in 1:n)
{
lines(time[1:i], rwData[1:i,j], col=ncolors[j], lty=j )
}
Sys.sleep(sleep)
}
}
randWalk(S=10,step=10,tmax=1e4)
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
ecovirtual
Ecovirtual
EcoVirtual
library("EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
library("RcmdrPlugin.EcoVirtual", lib.loc="/home/melina/R/i686-pc-linux-gnu-library/2.15")
install.packages("/home/melina/SVN_PI/ecovirtual/RcmdrPlugin.EcoVirtual_0.01.tar.gz" ,repos=NULL) # VAIO new
install.packages("/home/melina/SVN/ecovirtual/RcmdrPlugin.EcoVirtual_0.01.tar.gz" ,repos=NULL) # VAIO new
detach("package:Rcmdr", unload=TRUE)
detach("package:RcmdrPlugin.EcoVirtual", unload=TRUE)
